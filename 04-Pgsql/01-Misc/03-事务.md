## 事务特性和隔离
- SQL事务特性ACID：
    - `原子性(A)`
    - `一致性(C)`
    - `隔离性(I)`
    - `持久性(D)`
- SQL事务不隔离，会导致以下问题：
    - 脏读      ：读到其他事务未提交数据
    - 不可重复读：前后2次读取的同1条记录的内容不同(被其他事务修改)
    - 幻读      ：前后2次读取的同1数据集的条数不同(被其他事务新增或删除记录)
    - 更新丢失  ：同1条记录，前1事务修改结果被后1事务的修改结果覆盖
        - 此情况可归属于不可重复读 
        - 事务回滚也会导致记录修改，仅需设置隔离级别可防止此问题
    - 注：以上问题大部分由`read-then-update`导致 
- SQL定义以下事务隔离级别，以解决以上问题
    - 读未提交：允许脏读
    - 读已提交：不允许脏读
    - 可重复读：不允许不可重复读
    - 串行化读：不允许幻读
    - 注1：隔离级别从低到高，事务并发性从高到低
    - 注2：下1隔离级别可防止上1隔离级别的隔离问题
- 串行化指同1时刻仅有1个事务执行，但不保证事务按照开始时间顺序执行
- 广义幻读(P3)：T1读取数据->T2新增/删除T1读取的数据集->T1未再次读取

## 事务隔离实现-锁
- 隔离实现：
    - 仅有获取锁的事务可以读/写数据 
- 锁的目标类型
    - 表锁：加锁快，并发低
    - 行锁：加锁慢，并发高
    - 页锁：介于表锁和行锁
    - 注：页指数据库最小存储单位，一般为几KB

#### 悲观锁
- 悲观锁：必须先获取锁才能操作数据，数据库一般仅支持悲观锁
- 互斥锁：同1时刻仅允许一个事务获取
- 共享锁：同1时刻可允许多个事务获取
- 隐式悲观锁：执行CUD等SQL语句会自动尝试获取锁
- 显式悲观锁：
    - `for update` 互斥锁，用于写操作。可理解为读写锁的写锁
    - `for share`  共享锁，用于读操作。可理解为读写锁的读锁
- 悲观锁加锁过程(锁的实际调度跟数据库有关):
    - t1获取读锁   ：成功
    - t2获取读锁   ：成功，因为读锁是共享锁
    - t3获取写锁   ：等待t1，t2释放锁
    - t4获取读/写锁：等待t3释放锁，因为写锁是互斥锁
- 注意：如果事务获取`for share`锁后更新记录，可能导致死锁

#### 乐观锁
- 乐观锁：即`CAS(Compare and Set)`
- 一般数据库不支持乐观锁，需自行实现
```
--查询记录当前状态，客户端需自行保存查询值
select amount from t_account where id=1

--更新记录，如果记录值和前面查询相同
update t_account set amount=100 
where id=1 and amount=:amount
```