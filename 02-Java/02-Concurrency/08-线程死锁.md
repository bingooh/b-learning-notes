## 基本概念
- 死锁`deadlock`
    - 线程A等待获取线程B持有的资源，视为1条有向线段`A->B`
    - 任何时刻，如果有向线段形成了1个有向闭环图，即为死锁
- 数据库事务如果形成死锁，数据库进程将随机终止1个事务(受害者), JVM则会一直等待
- 已持有1个锁的线程，执行另1个需要获取其他锁的方法时，即可能造成死锁
- `open call` 未使用`synchronized`修饰的方法
    - 执行此方法不需要获取锁，能尽可能的减少死锁
    - 方法内部仍然可以使用同步块，仅对需要同步的资源加锁
- `resource deadlock` 见P213，对象固有锁可视为1种资源
    - 在单线程池里，当前执行任务等待后1任务执行结束 
- `livelock` 类似死循环
    - 在事务型线程池里，当前任务总是执行出错，但是回滚事务把当前任务重新放入工作队列首部
    - 两个相对而行的人，总是同时往相同的方向为对方让路
- `starvation` 
    - 长期运行的任务一直持有锁，导致其他线程获取不到锁而一直等待
    - 修改了线程的优先级，导致低优先级的任务总是不能获取CPU资源
    - 建议使用`Thread.yield()`，不要修改线程的优先级
- `低响应`
    - 线程池执行太多的长期运行任务，导致短任务无法执行 
    - 资源太少(如数据库连接对象)，需要资源的线程过多

## 性能调优
- 先保证正确，再进行性能调优
- 性能调优需要考虑程序扩展性
    - 单体不分层的程序性能最高，但是扩展性几乎为零
- 优化串行执行的代码
    - 考虑使用`ConcurrentXXX`替代`syncronizedXXX()`  
    - 减少线程上下文切换(每个线程堆栈1M??)
    - 减少内存同步，如使用`volatile`
- 减少竞争锁
    - 减少锁的持有时间
    - 减少请求获取锁的频率
    - 减少使用`mutex`(互斥锁)
- 减少竞争锁的方法
    - 减少锁的范围`scope`
    - 减少锁的粒度，每个**独立的状态**使用1个独立的锁守卫
    - 使用`lock stripe` 见P237
    - 使用`ReadWriteLock`等非排他锁
